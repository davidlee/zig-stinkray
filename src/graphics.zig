const std = @import("std");
const rl = @import("raylib");
const p = @import("player.zig");
const t = @import("terrain.zig");
const m = @import("main.zig");

const CELL_SIZE: i32 = 15;
const CELL_MIDPOINT: i32 = CELL_SIZE / 2;

const CELL_SIZE_F: f32 = @floatFromInt(CELL_SIZE);
const CELL_MIDPOINT_F: f32 = CELL_SIZE_F / 2.0;
const light_radius: usize = 15;

var camera: rl.Camera2D = undefined;
pub var wheel: f32 = 0;

pub var screenWidth: i32 = 1800;
pub var screenHeight: i32 = 1600;
var viewportWidth: usize = 80;
var viewportHeight: usize = 80;
var viewport: rl.RenderTexture = undefined;
var frame_count: usize = 0;
var bounding_box_endpoints: [8]m.WallEndpoint = undefined;

pub fn init(world: *m.World) void {
    _ = world;
    rl.initWindow(screenWidth, screenHeight, "raylib-zig [core] example - basic window");
    rl.setTargetFPS(60);
    screenWidth = rl.getScreenWidth();
    screenHeight = rl.getScreenHeight();
    const fw: f32 = @floatFromInt(screenWidth);
    const fh: f32 = @floatFromInt(screenHeight);

    camera = rl.Camera2D{
        .offset = rl.Vector2.init(fw / 2.0, fh / 2.0),
        .target = rl.Vector2.init(0, 0), // centered on the top left of player tile
        .rotation = 0,
        .zoom = 1,
    };
}

pub fn deinit() void {
    defer rl.closeWindow();
}

//
// draw functions
//

pub fn draw(world: *m.World) void {
    frame_count +%= 1;
    const scaleFactor = 1.0 + (0.25 * wheel);
    camera.rotation = -world.player.rotation;
    camera.zoom = std.math.clamp(camera.zoom * scaleFactor, 0.425, 8.0);
    camera.target = rl.Vector2.init(world.player.position.x * CELL_SIZE, world.player.position.y * CELL_SIZE);

    rl.beginDrawing();
    defer rl.endDrawing();

    rl.clearBackground(rl.Color.black);
    rl.beginMode2D(camera);
    {
        // TODO only do all this stuff when it's changed a
        drawCells(world) catch unreachable;
        drawPlayer(&world.player);
        prepareWallSegments(world, light_radius);
        drawVisibilityDebug(world, light_radius);
    }
    rl.endMode2D();
}

fn drawPlayer(player: *p.Player) void {
    const x: i32 = @intFromFloat(player.position.x * CELL_SIZE - CELL_MIDPOINT_F);
    const y: i32 = @intFromFloat(player.position.y * CELL_SIZE - CELL_MIDPOINT_F);
    rl.drawRectangle(x, y, CELL_SIZE, CELL_SIZE, rl.Color.red);
}

fn drawCells(world: *m.World) !void {
    var al = std.ArrayList(t.RectAddr).init(world.allocator);
    defer al.deinit();

    const pos = world.player.position.uvec3();
    world.cells.getRect(
        &al,
        pos.x,
        pos.y,
        pos.z,
        viewportWidth,
        viewportHeight,
    );

    for (al.items) |it| {
        drawCell(&it.cell, it.x, it.y);
    }
}

fn drawCell(cell: *const t.Cell, x: usize, y: usize) void {
    const display_x: i32 = m.cast(i32, x) * CELL_SIZE;
    const display_y: i32 = m.cast(i32, y) * CELL_SIZE;
    switch (cell.tile) {
        .Empty => rl.drawRectangle(display_x, display_y, CELL_SIZE, CELL_SIZE, rl.Color.dark_gray),
        .Floor => |mat| {
            switch (mat) {
                .Iron => {
                    rl.drawRectangle(display_x, display_y, CELL_SIZE, CELL_SIZE, rl.Color.init(20, 30, 20, 255));
                    rl.drawRectangle(display_x + 3, display_y + 3, 4, 4, rl.Color.init(50, 50, 40, 255));
                },
                else => {
                    rl.drawRectangle(display_x, display_y, CELL_SIZE, CELL_SIZE, rl.Color.init(48, 33, 22, 255));
                    rl.drawRectangle(display_x + 4, display_y + 4, 4, 4, rl.Color.init(18, 25, 44, 255));
                },
            }
        },
        .Solid => rl.drawRectangle(display_x, display_y, CELL_SIZE, CELL_SIZE, rl.Color.black),
    }
}

// https://legends2k.github.io/2d-fov/design.html

// sweep a line from the player's position across the screen
// and fill in the triangles generated by the rays as they intersect walls.

// 1. Calculate the angles where walls begin or end.
// 2. Cast a ray from the center along each angle.
// 3. Fill in the triangles generated by those rays.

// In more detail:

// var endpoints;   # list of endpoints, sorted by angle
// var open = [];   # list of walls the sweep line intersects

// loop over endpoints:
//     remember which wall is nearest
//     add any walls that BEGIN at this endpoint to 'walls'
//     remove any walls that END at this endpoint from 'walls'

//     figure out which wall is now nearest
//     if the nearest wall changed:
//         fill the current triangle and begin a new one

// data structures:
//
// Output is an arraylist of Vec2 which form a visible area polygon.

fn prepareWallSegments(world: *m.World, range: usize) void {
    const viewpoint: m.Vec2 = .{ .x = world.player.position.x, .y = world.player.position.y };

    // var output = std.ArrayList(m.Vec2).init(world.allocator);
    // defer output.deinit();

    var segments = std.ArrayList(m.WallSegment).init(world.allocator);
    defer segments.deinit();
    findWallSegmentsInBoundingBox(world, &segments, viewpoint.x, viewpoint.y, range);

    var endpoints = std.ArrayList(m.WallEndpoint).init(world.allocator);
    defer endpoints.deinit();
    for (segments.items) |*seg| {
        endpoints.append(seg.p1.*) catch unreachable;
        endpoints.append(seg.p2.*) catch unreachable;
    }

    // sort so that endpoints are in order of angle
    std.mem.sort(m.WallEndpoint, endpoints.items, {}, m.WallEndpoint.cmp);

    // draw debug lines
    //
    for (segments.items) |s| {
        rl.drawLine(m.intf(i32, s.p1.x * CELL_SIZE), m.intf(i32, s.p1.y * CELL_SIZE), m.intf(i32, s.p2.x * CELL_SIZE), m.intf(i32, s.p2.y * CELL_SIZE), rl.Color.yellow);
    }
    for (endpoints.items) |*ep| {
        drawLineFromPlayerTo(world, m.intf(usize, ep.x), m.intf(usize, ep.y), rl.Color.init(255, 0, 0, 80));
    }
    const e = endpoints.items[frame_count % endpoints.items.len];
    drawLineFromPlayerTo(world, m.intf(usize, e.x), m.intf(usize, e.y), rl.Color.white);

    // ok now we just have to remove non-nearest segments
    // ie when a line to them from the viewer crosses another segment
    //
    // and fill in the triangles they generate

}

fn findWallSegmentsInBoundingBox(world: *m.World, array_list: *std.ArrayList(m.WallSegment), x: f32, y: f32, range: usize) void {
    const r: f32 = @floatFromInt(range);
    const bx1 = @min(@max(0, x - r), m.flint(f32, world.cells.getWidth() + 1));
    const bx2 = @min(@max(0, x + r), m.flint(f32, world.cells.getWidth() + 1));
    const by1 = @min(@max(0, y - r), m.flint(f32, world.cells.getHeight() + 1));
    const by2 = @min(@max(0, y + r), m.flint(f32, world.cells.getHeight() + 1));

    var segs: [4]m.WallSegment = undefined;

    var first: m.WallSegment = undefined; // top
    var intersecting: bool = false;
    var i: usize = 0;

    for (world.wall_segments.items) |*s| {
        // they come in groups of 4, top left corner first
        if (s.p1.top_left) {
            first = s.*;
            segs = .{ first, undefined, undefined, undefined };
            intersecting = false;
            i = 0;
        } else {
            // roll em up
            i += 1;
            segs[i] = s.*;
        }

        if (!intersecting) {
            if (rectIntersectsPoint(bx1, by1, bx2, by2, s.p1.x, s.p1.y) or
                rectIntersectsPoint(bx1, by1, bx2, by2, s.p2.x, s.p2.y))
            {
                intersecting = true;
            }
        }

        if (intersecting and i == 3) {
            // got em all, now calc angles and dist
            var walls = std.ArrayList(m.WallSegment).init(world.allocator);
            defer walls.deinit();
            // cull rear walls
            collectFacingSegments(segs, &walls, x, y);
            for (walls.items) |*seg| {
                seg.p1.angle = angleTo(seg.p1.x, seg.p1.y, x, y);
                seg.p2.angle = angleTo(seg.p2.x, seg.p2.y, x, y);

                seg.d = (seg.p1.x - x) * (seg.p1.x - x) + (seg.p1.y - y) * (seg.p1.y - y);
                array_list.append(seg.*) catch unreachable;
            }
        }
    }

    // add segments to represent the bounding box
    // these are transient, so .. bit of a hack:
    // we keep the endpoints in a separate array, bounding_box_endpoints
    // that way we can reference them from the segment structs
    // without corrupting the "real" endpoints
    {
        const tl = m.WallEndpoint{ .x = bx1, .y = by1 };
        const tr = m.WallEndpoint{ .x = bx2, .y = by1 };
        const br = m.WallEndpoint{ .x = bx2, .y = by2 };
        const bl = m.WallEndpoint{ .x = bx1, .y = by2 };

        addBoundingSegment(array_list, x, y, tl.x, tl.y, tr.x, tr.y, 0);
        addBoundingSegment(array_list, x, y, tr.x, tr.y, br.x, br.y, 1);
        addBoundingSegment(array_list, x, y, br.x, br.y, bl.x, bl.y, 2);
        addBoundingSegment(array_list, x, y, bl.x, bl.y, tl.x, tl.y, 3);
    }
}

fn addBoundingSegment(array_list: *std.ArrayList(m.WallSegment), x: f32, y: f32, x1: f32, y1: f32, x2: f32, y2: f32, index: usize) void {
    const p1 = m.WallEndpoint{ .x = x1, .y = y1 };
    const p2 = m.WallEndpoint{ .x = x2, .y = y2 };
    // ugly dance to ensure seg gets a live reference
    bounding_box_endpoints[index] = p1;
    bounding_box_endpoints[index + 4] = p2;
    var seg = m.WallSegment{ .p1 = &bounding_box_endpoints[index], .p2 = &bounding_box_endpoints[index + 4] };

    seg.p1.angle = angleTo(seg.p1.x, seg.p1.y, x, y);
    seg.p2.angle = angleTo(seg.p2.x, seg.p2.y, x, y);
    seg.d = (seg.p1.x - x) * (seg.p1.x - x) + (seg.p1.y - y) * (seg.p1.y - y);

    array_list.append(seg) catch unreachable;
}

fn collectFacingSegments(segs: [4]m.WallSegment, facing: *std.ArrayList(m.WallSegment), x: f32, y: f32) void {
    // determine facing walls based on relative position to player at x,y
    const tl = segs[0].p1;
    const br = segs[2].p2;

    const top = segs[0];
    const right = segs[1];
    const bottom = segs[2];
    const left = segs[3];

    const qs: [2]m.Quadrant = .{ m.quadrant(tl.x - x, tl.y - y), m.quadrant(br.x - x, br.y - y) };
    if (qs[0] == qs[1]) {
        switch (qs[0]) {
            .q_I => {
                facing.append(left) catch unreachable;
                facing.append(bottom) catch unreachable;
            },
            .q_II => {
                facing.append(bottom) catch unreachable;
                facing.append(right) catch unreachable;
            },
            .q_III => {
                facing.append(top) catch unreachable;
                facing.append(right) catch unreachable;
            },
            .q_IV => {
                facing.append(top) catch unreachable;
                facing.append(left) catch unreachable;
            },
            .none => unreachable,
        }
    } else {
        if (br.x - x < 0) {
            facing.append(right) catch unreachable;
        } else if (tl.x - x > 0) {
            facing.append(left) catch unreachable;
        } else if (br.y - y < 0) {
            facing.append(bottom) catch unreachable;
        } else if (tl.y - y > 0) {
            facing.append(top) catch unreachable;
        }
    }
}

fn drawVisibilityDebug(world: *m.World, range: usize) void {
    const px: i32 = @intFromFloat(world.player.position.x * CELL_SIZE);
    const py: i32 = @intFromFloat(world.player.position.y * CELL_SIZE);

    const fc: i32 = @intCast(frame_count);
    const alpha = m.cast(u8, @abs(@rem(fc, 100) - 50) / 1);
    const k: i32 = m.cast(i32, range * CELL_SIZE * 2);

    // draw a circle at visible range around the player
    rl.drawCircleLines(px, py, @floatFromInt(range * CELL_SIZE), rl.Color.init(0, 255, 0, alpha));
    rl.drawRectangleLines(px - @divFloor(k, 2), py - @divFloor(k, 2), k, k, rl.Color.init(255, 255, 0, alpha));

    // draw fov arc for player
    const c = rl.Color.init(255, 255, 255, 40);
    const centre = rl.Vector2.init(world.player.position.x * CELL_SIZE_F, world.player.position.y * CELL_SIZE_F);
    const a1: f32 = @mod(360 - 90 + world.player.rotation - world.player.fov_angle / 2, 360);
    const a2: f32 = a1 + world.player.fov_angle;
    rl.drawCircleSectorLines(centre, 1000, a1, a2, 8, c);
    const r: f32 = world.player.fov_radius * CELL_SIZE_F;
    const b1: f32 = 15 + world.player.rotation;
    const b2: f32 = b1 - (180 + 15 * 2);
    rl.drawCircleSectorLines(centre, r, b1, b2, 24, c);
}

//
// utility functions
//

fn angleTo(x1: f32, y1: f32, x2: f32, y2: f32) f32 {
    return std.math.atan2(y2 - y1, x2 - x1);
}

fn distanceOfUvec2s(a: m.Uvec2, b: m.Uvec2) f32 {
    const ax: f32 = @floatFromInt(a.x);
    const ay: f32 = @floatFromInt(a.y);
    const bx: f32 = @floatFromInt(b.x);
    const by: f32 = @floatFromInt(b.y);
    return std.math.sqrt((bx - ax) * (bx - ax) + (by - ay) * (by - ay));
}

fn rectIntersectsPoint(x1: f32, y1: f32, x2: f32, y2: f32, px: f32, py: f32) bool {
    return (x1 <= px and x2 >= px and y1 <= py and y2 >= py);
}

fn interpolate(pp: m.Vec2, pq: m.Vec2, f: f32) m.Vec2 {
    return m.Vec2{ .x = pp.x * (1 - f) + pq.x * f, .y = pp.y * (1 - f) + pq.y * f };
}

fn leftOf(s: m.WallSegment, pt: m.Vec2) bool {
    const cross = (s.p2.x - s.p1.x) * (pt.y - s.p1.y) - (s.p2.y - s.p1.y) * (pt.x - s.p1.x);
    return cross < 0;
}

// TODO split segments at intersection
fn intersectionDetected(a: m.WallSegment, b: m.WallSegment) void {
    _ = a;
    _ = b;
}

fn segmentInFrontOf(a: m.WallSegment, b: m.WallSegment, relativeTo: m.Vec2) bool {
    const a1 = leftOf(a, interpolate(b.p1, b.p2, 0.01));
    const a2 = leftOf(a, interpolate(b.p2, b.p1, 0.01));
    const a3 = leftOf(a, relativeTo);
    const b1 = leftOf(b, interpolate(a.p1, a.p2, 0.01));
    const b2 = leftOf(b, interpolate(a.p2, a.p1, 0.01));
    const b3 = leftOf(b, relativeTo);
    if (b1 == b2 and b2 != b3) return true;
    if (a1 == a2 and a2 == a3) return true;
    if (a1 == a2 and a2 != a3) return false;
    if (b1 == b2 and b2 == b3) return false;

    // intersectionDetected(a, b);
    return false;
}
fn drawLineFromPlayerTo(world: *m.World, x: usize, y: usize, color: rl.Color) void {
    const px: i32 = @intFromFloat(world.player.position.x * CELL_SIZE_F);
    const py: i32 = @intFromFloat(world.player.position.y * CELL_SIZE_F);

    const pt = m.Ivec2{
        .x = m.cast(i32, x * CELL_SIZE),
        .y = m.cast(i32, y * CELL_SIZE),
    };
    rl.drawLine(px, py, pt.x, pt.y, color);
}

const half_pi: f32 = std.math.pi / @as(f32, 2.0);

fn drawLineToBoundingBox(world: *m.World, x: usize, y: usize, range: i32, alpha: u8) void {
    const px: f32 = (world.player.position.x) * CELL_SIZE_F;
    const py: f32 = (world.player.position.y) * CELL_SIZE_F;

    const angle: f32 = angleTo(px, py, m.flint(f32, x) * CELL_SIZE_F, m.flint(f32, y) * CELL_SIZE_F);

    // brutishly finding the distance to the edge of the range rectangle
    const len1: f32 = @abs(m.flint(f32, range) / std.math.sin(half_pi - angle));
    const len2: f32 = @abs(m.flint(f32, range) / std.math.cos(half_pi - angle));
    const len = @min(len1, len2);

    const tx: f32 = px + std.math.cos(angle) * len;
    const ty: f32 = py + std.math.sin(angle) * len;

    rl.drawLine(
        @intFromFloat(px),
        @intFromFloat(py),
        @intFromFloat(tx),
        @intFromFloat(ty),
        rl.Color.init(0, 255, 255, alpha),
    );
}
